{"version":3,"file":"main.25a9c942a3a618746d36.hot-update.js","mappings":";;;;;;;;;;;;;;;;AAAkC;AACY;AACQ;;AAEvC;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAO;AAC5B,qBAAqB,wDAAc;AACnC,qBAAqB,4DAAkB;AACvC,oCAAoC,gBAAgB;AACpD;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;ACzBA;AACA,aAAa,uBAAuB;AACpC,aAAa,qBAAqB;AAClC,aAAa,wBAAwB;AACrC,aAAa,wBAAwB;AACrC,aAAa,qBAAqB;AAClC,aAAa,wBAAwB;AACrC,aAAa,gCAAgC;AAC7C,aAAa,oBAAoB;AACjC;;AAE4C;AACb;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa;AACb;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA,uBAAuB,6DAAiB,GAAG,yCAAC,GAAG,yCAAC;AAChD;AACA,cAAc,8DAAkB;AAChC,aAAa,0BAA0B;AACvC;AACA;AACA,cAAc,8DAAkB;AAChC;AACA,aAAa,yBAAyB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,aAAa;AACb;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AA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","sources":["webpack://svelte-app/./src/parse.js","webpack://svelte-app/../node_modules/hast-util-from-dom/lib/index.js","webpack://svelte-app/../node_modules/hast-util-to-dom/lib/index.js","webpack://svelte-app/../node_modules/rehype-dom-parse/index.js","webpack://svelte-app/../node_modules/rehype-dom-parse/lib/index.js","webpack://svelte-app/../node_modules/rehype-dom-stringify/index.js","webpack://svelte-app/../node_modules/rehype-dom-stringify/lib/index.js","webpack://svelte-app/webpack/runtime/getFullHash"],"sourcesContent":["import { unified } from \"unified\";\nimport rehypeDomParse from \"rehype-dom-parse\";\nimport rehypeDomStringify from \"rehype-dom-stringify\";\n\nexport default function parse(ast) {\n    let story = [];\n    let currentUnit = {};\n    ast.forEach((unit) => {\n        console.log(unit);\n        // if(unit.)\n        switch (unit.tagName) {\n            case \"p\":\n                break;\n            case \"blockquote\":\n                break;\n        }\n        story.push({\n            content: unified()\n                .use(rehypeDomParse)\n                .use(rehypeDomStringify)\n                .data(\"settings\", { fragment: true })\n                .parse(unit.children),\n        });\n    });\n    return story;\n}\n","/**\n * @typedef {import('hast').Parent} HastParent\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').DocType} HastDoctype\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {HastParent['children'][number]} HastChild\n * @typedef {HastChild|HastRoot} HastNode\n */\n\nimport {webNamespaces} from 'web-namespaces'\nimport {h, s} from 'hastscript'\n\nconst ELEMENT_NODE = 1\nconst TEXT_NODE = 3\nconst COMMENT_NODE = 8\nconst DOCUMENT_NODE = 9\nconst DOCUMENT_TYPE_NODE = 10\nconst DOCUMENT_FRAGMENT_NODE = 11\n\n/**\n * @param {Node} node\n * @returns {HastNode|undefined}\n */\nfunction transform(node) {\n  switch (node.nodeType) {\n    case ELEMENT_NODE:\n      // @ts-expect-error TypeScript is wrong.\n      return element(node)\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      // @ts-expect-error TypeScript is wrong.\n      return root(node)\n    case TEXT_NODE:\n      // @ts-expect-error TypeScript is wrong.\n      return text(node)\n    case COMMENT_NODE:\n      // @ts-expect-error TypeScript is wrong.\n      return comment(node)\n    case DOCUMENT_TYPE_NODE:\n      return doctype()\n    default:\n      return undefined\n  }\n}\n\n/**\n * Transform a document.\n *\n * @param {Document|DocumentFragment} node\n * @returns {HastRoot}\n */\nfunction root(node) {\n  return {type: 'root', children: all(node)}\n}\n\n/**\n * Transform a doctype.\n *\n * @returns {HastDoctype}\n */\nfunction doctype() {\n  // @ts-expect-error hast types out of date.\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n * @returns {HastText}\n */\nfunction text(node) {\n  return {type: 'text', value: node.nodeValue || ''}\n}\n\n/**\n * Transform a comment.\n *\n * @param {Comment} node\n * @returns {HastComment}\n */\nfunction comment(node) {\n  return {type: 'comment', value: node.nodeValue || ''}\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n * @returns {HastElement}\n */\nfunction element(node) {\n  const space = node.namespaceURI\n  const fn = space === webNamespaces.svg ? s : h\n  const tagName =\n    space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName\n  /** @type {DocumentFragment|Element} */\n  const content =\n    // @ts-expect-error Types are wrong.\n    space === webNamespaces.html && tagName === 'template' ? node.content : node\n  const attributes = node.getAttributeNames()\n  /** @type {Object.<string, string>} */\n  const props = {}\n  let index = -1\n\n  while (++index < attributes.length) {\n    props[attributes[index]] = node.getAttribute(attributes[index]) || ''\n  }\n\n  return fn(tagName, props, all(content))\n}\n\n/**\n * Transform an element.\n *\n * @param {Document|DocumentFragment|Element} node\n * @returns {Array.<HastChild>}\n */\nfunction all(node) {\n  const nodes = node.childNodes\n  /** @type {Array.<HastChild>} */\n  const children = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const child = transform(nodes[index])\n\n    if (child !== undefined) {\n      // @ts-expect-error Assume no document inside document.\n      children.push(child)\n    }\n  }\n\n  return children\n}\n\n/**\n * @param {Node} node\n * @returns {HastNode}\n */\nexport function fromDom(node) {\n  return transform(node || {}) || {type: 'root', children: []}\n}\n","/**\n * @typedef {import('hast').Parent} HastParent\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').DocType} HastDoctype\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {HastParent['children'][number]} HastChild\n * @typedef {HastChild|HastRoot} HastNode\n *\n * @typedef Options\n * @property {boolean} [fragment=false] Whether a DOM fragment should be returned\n * @property {Document} [document] Document interface to use (default: `globalThis.document`)\n * @property {string} [namespace] `namespace` to use to create elements\n *\n * @typedef Context\n * @property {Document} doc\n * @property {boolean} [fragment=false]\n * @property {string} [namespace]\n * @property {string} [impliedNamespace]\n */\n\nimport {webNamespaces} from 'web-namespaces'\nimport {find, html, svg} from 'property-information'\n\n/* eslint-env browser */\n\n/**\n * @param {HastNode} node\n * @param {Context} [ctx]\n */\nfunction transform(node, ctx) {\n  switch (node.type) {\n    case 'root':\n      return root(node, ctx)\n    case 'text':\n      return text(node, ctx)\n    case 'element':\n      return element(node, ctx)\n    case 'doctype':\n      return doctype(node, ctx)\n    case 'comment':\n      return comment(node, ctx)\n    default:\n      return element(node, ctx)\n  }\n}\n\n/**\n * Create a document.\n *\n * @param {HastRoot} node\n * @param {Context} ctx\n * @returns {XMLDocument|DocumentFragment|HTMLHtmlElement}\n */\nfunction root(node, ctx) {\n  const {doc, fragment, namespace: ctxNamespace} = ctx\n  const {children = []} = node\n  const {length: childrenLength} = children\n\n  let namespace = ctxNamespace\n  let rootIsDocument = childrenLength === 0\n\n  for (let i = 0; i < childrenLength; i += 1) {\n    const child = children[i]\n\n    if (child.type === 'element' && child.tagName === 'html') {\n      const {properties = {}} = child\n\n      // If we have a root HTML node, we don’t need to render as a fragment.\n      rootIsDocument = true\n\n      // Take namespace of the first child.\n      if (typeof ctxNamespace === 'undefined') {\n        namespace = String(properties.xmlns || '') || webNamespaces.html\n      }\n    }\n  }\n\n  // The root node will be a Document, DocumentFragment, or HTMLElement.\n  /** @type {XMLDocument|DocumentFragment|HTMLHtmlElement} */\n  let result\n\n  if (rootIsDocument) {\n    result = doc.implementation.createDocument(namespace, '', null)\n  } else if (fragment) {\n    result = doc.createDocumentFragment()\n  } else {\n    result = doc.createElement('html')\n  }\n\n  return appendAll(result, children, {\n    ...ctx,\n    fragment,\n    namespace,\n    impliedNamespace: namespace\n  })\n}\n\n/**\n * Create a `doctype`.\n *\n * @param {HastDoctype} _\n * @param {Context} ctx\n * @returns {DocumentType}\n */\nfunction doctype(_, {doc}) {\n  return doc.implementation.createDocumentType('html', '', '')\n}\n\n/**\n * Create a `text`.\n *\n * @param {HastText} node\n * @param {Context} ctx\n * @returns {Text}\n */\nfunction text(node, {doc}) {\n  return doc.createTextNode(node.value)\n}\n\n/**\n * Create a `comment`.\n *\n * @param {HastComment} node\n * @param {Context} ctx\n * @returns {Comment}\n */\nfunction comment(node, {doc}) {\n  return doc.createComment(node.value)\n}\n\n/**\n * Create an `element`.\n *\n * @param {HastElement} node\n * @param {Context} ctx\n * @returns {Element}\n */\n// eslint-disable-next-line complexity\nfunction element(node, ctx) {\n  const {namespace, doc} = ctx\n  let impliedNamespace = ctx.impliedNamespace || namespace\n  const {\n    tagName = impliedNamespace === webNamespaces.svg ? 'g' : 'div',\n    properties = {},\n    children = []\n  } = node\n\n  if (\n    (impliedNamespace === null ||\n      impliedNamespace === undefined ||\n      impliedNamespace === webNamespaces.html) &&\n    tagName === 'svg'\n  ) {\n    impliedNamespace = webNamespaces.svg\n  }\n\n  const schema = impliedNamespace === webNamespaces.svg ? svg : html\n\n  const result =\n    impliedNamespace === null || impliedNamespace === undefined\n      ? doc.createElement(tagName)\n      : doc.createElementNS(impliedNamespace, tagName)\n\n  // Add HTML attributes.\n  const props = Object.keys(properties)\n  const {length} = props\n\n  for (let i = 0; i < length; i += 1) {\n    const key = props[i]\n\n    const {\n      attribute,\n      property,\n      // `mustUseAttribute`,\n      mustUseProperty,\n      boolean,\n      booleanish,\n      overloadedBoolean,\n      // `number`,\n      // `defined`,\n      commaSeparated\n      // `spaceSeparated`,\n      // `commaOrSpaceSeparated`,\n    } = find(schema, key)\n\n    let value = properties[key]\n\n    if (Array.isArray(value)) {\n      value = value.join(commaSeparated ? ', ' : ' ')\n    }\n\n    if (mustUseProperty) {\n      result[property] = value\n    }\n\n    if (boolean || (overloadedBoolean && typeof value === 'boolean')) {\n      if (value) {\n        result.setAttribute(attribute, '')\n      } else {\n        result.removeAttribute(attribute)\n      }\n    } else if (booleanish) {\n      result.setAttribute(attribute, String(value))\n    } else if (value === true) {\n      result.setAttribute(attribute, '')\n    } else if (value || value === 0 || value === '') {\n      result.setAttribute(attribute, String(value))\n    }\n  }\n\n  return appendAll(result, children, {...ctx, impliedNamespace})\n}\n\n/**\n * Add all children.\n *\n * @template {Node} N\n * @param {N} node\n * @param {Array.<HastChild>} children\n * @param {Context} ctx\n * @returns {N}\n */\nfunction appendAll(node, children, ctx) {\n  let index = -1\n\n  while (++index < children.length) {\n    // eslint-disable-next-line unicorn/prefer-dom-node-append\n    node.appendChild(transform(children[index], ctx))\n  }\n\n  return node\n}\n\n/**\n * Transform a hast tree to a DOM tree\n *\n * @param {HastNode} node\n * @param {Options} [options]\n * @returns {Node}\n */\nexport function toDom(node, options = {}) {\n  const {document: doc = document, ...rest} = options\n  return transform(node, {doc, ...rest})\n}\n","import rehypeDomParse from './lib/index.js'\n\nexport default rehypeDomParse\n","/**\n * @typedef {import('hast').Root} Root\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean} [fragment=true]\n *   Specify whether to parse a fragment, instead of a complete document.\n *   In document mode, unopened `html`, `head`, and `body` elements are opened\n *   in just the right places.\n */\n\nimport {fromDom} from 'hast-util-from-dom'\n\n/** @type {import('unified').Plugin<[Options?] | void[], string, Root>} */\nexport default function parse(options) {\n  const settings = /** @type {Options} */ (this.data('settings'))\n  const {fragment} = {...options, ...settings}\n\n  Object.assign(this, {Parser: parser})\n\n  /** @type {import('unified').ParserFunction<Root>} */\n  function parser(doc) {\n    const create =\n      fragment === null || fragment === undefined || fragment\n        ? createFragment\n        : createDocument\n    return /** @type {Root} */ (fromDom(create(doc)))\n  }\n}\n\nconst DOCUMENT_FRAGMENT_NODE = 11\n\n/**\n * @param {string} htmlString\n * @returns {DocumentFragment}\n */\nfunction createFragment(htmlString) {\n  const doc = createDocument('<!doctype html><body>' + htmlString)\n\n  /**\n   * Pretend as a DocumentFragment node,\n   * @see https://github.com/rehypejs/rehype-dom/pull/19 for more details\n   */\n  return /** @type {DocumentFragment} */ ({\n    nodeType: DOCUMENT_FRAGMENT_NODE,\n    childNodes: doc.body.childNodes\n  })\n}\n\n/**\n * @param {string} htmlString\n * @returns {Document}\n */\nfunction createDocument(htmlString) {\n  return new DOMParser().parseFromString(htmlString, 'text/html')\n}\n","import rehypeDomStringify from './lib/index.js'\n\nexport default rehypeDomStringify\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast-util-to-dom').Options} Options\n */\n\nimport {toDom} from 'hast-util-to-dom'\nimport {webNamespaces} from 'web-namespaces'\n\nconst htmlXmlnsExpression = new RegExp(` xmlns=\"${webNamespaces.html}\"`, 'g')\n\n/** @type {import('unified').Plugin<[Options?] | void[], Root, string>} */\nexport default function stringify(options) {\n  const config = /** @type {Options} */ (this.data('settings'))\n  const settings = {...options, ...config}\n\n  if (settings.fragment === null || settings.fragment === undefined) {\n    settings.fragment = true\n  }\n\n  Object.assign(this, {Compiler: compiler})\n\n  /** @type {import('unified').CompilerFunction<Root, string>} */\n  function compiler(tree) {\n    const node = toDom(tree, settings)\n    const serialized = new XMLSerializer().serializeToString(node)\n\n    // XMLSerializer puts xmlns on root elements (typically the document\n    // element, but in case of a fragment all of the fragments children).\n    // We’re using the DOM, and we focus on HTML, so we can always remove HTML\n    // XMLNS attributes (HTML inside SVG does not need to have an XMLNS).\n    return serialized.replace(htmlXmlnsExpression, '')\n  }\n}\n","__webpack_require__.h = () => (\"7be43319d4815a13db9f\")"],"names":[],"sourceRoot":""}